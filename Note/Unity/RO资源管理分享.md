# 资源管理

## 目标

* 简单接口
* 冗余资源
* 重复加载
* 资源泄漏

## 打包过程

1. 分析依赖
2. 合并依赖（去除重复依赖
3. 打标签打包

粒度过细，内存会变大，加载变慢
粒度过大，冗余

## 加载资源

伪异步，每帧计时，如果时间太长则进入下一帧再加载。
避免异步加载时插入同步加载。

需要注意的问题：
异步加载转同步加载，依赖项中途被加载完。打断同步加载，通过异步加载回调。

## 资源池

编辑器下Resources
运行用bundle

资源池引用计数（资源引用计数）

对象池（GameObject）

## 对象池淘汰策略

三个状态：
缓存状态，时间淘汰，立即淘汰

没有引用的时候，进入缓存队列，如果缓存资源已经不够用了，那就在一定时间之内释放，
如果实在太多的话就立即释放。

不论是什么池子都可以采用这种方式来做。

双向链表 + Hash表

删除的效率

## 相关优化

Assetbundle序列化文件优化：
提前卸载根资源，实例化出来之后就把资源卸载掉了，一些常驻资源可以这么做。
非根的材质和ScripableObject没办法卸载干净，所以不能提前卸载。（防止被其他资源依赖）

Destroy和UnloadAsset只能卸载资源本身，不能释放依赖的资源，只能通过Assetbundle.unload(true)才可以卸载。
保证资源不泄露的点。

Assetbundle根据容量打到Block中，海外小包策略做准备，解压速度提升。

## 坑

Unload(true)
虽然unload是同步调用，但是上层逻辑Destroy实际是多线程操作，同步卸载AB会导致野指针
所以需要等待一定时间后去unload

OnDestroy只有在Awake调用之后才会调用，一些卸载的操作不能在OnDestory中监听，而是TransformChanged进行监听（因为目前都是走对象池，所以可以保证一定会有回调到）

一张贴图有sprite的时候单独打AB引用材质会有冗余资源，图集管理的时候保证材质和贴图打在一起就可以去除这部分的冗余。
并且图集也需要打上标签，否则增量更新的时候会更新不成功。

## 一些bug回忆

需要立即添加引用计数，而不是加载完了才给这个资源添加引用计数。（防止加载中被卸载

异步转同步的时候，遍历的时候需要中断。

数据对象池减少GC时需要谨慎，避免被污染，放入对象池等一桢，被其他地方拿出来被修改了状态的话就会出问题。

场景资源如果有运行时资源的话，就在内存中会有冗余资源。

## 用例

依赖打包分包情况整理
异步转同步
引用计数统计
卸载资源卸干净
