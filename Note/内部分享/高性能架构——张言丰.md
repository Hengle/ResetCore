# 高性能架构——张言丰
#分享会/欢乐互娱#

## 架构综述
总体还是一个大循环
资源管理任务和渲染压力较大
大地表，后期效果

## 无限大地表
减少loading
减少内存（自己管理卸载）
Unity需要自己写streaming

问题：
### 场景划分
1. 九宫格划分：
美术在制作时需要进行分块（有一些可用插件）
用Terrain（？是否也可以使用Mesh）lightmap也是在一起加载

九宫格加载需要考虑因素：位置以及**视角**

优点：内存压力小，美术工作流不受限制
缺点：切开的接缝问题（Lightmap黑线）、视野穿帮问题

问题解决：
* 接缝使用装饰
* maya刷法线
* 调整切块尺寸
* 远处用山和雾进行过度

2. 语义划分

对物体做标记可见于不可见

优点：内存压力小，地表无接缝，逻辑简单
缺点：Lightmap尺寸大，美术手调工作量大

问题解决：
* 保证最近Lightmap加载，远处用雾效
* 用工具来调整能看到哪些物件

3. 地表不切块只加载物体

编辑时标LogGroup，通过工具学习生成数据，每个地点可以看到哪些物件
运行时Update进行监听，实时关闭或打开物件
（离线渲染的遮挡剔除）

优点：处理简单， 地表无接缝， 逻辑简单
缺点：内存大，渲染压力大，视角变化大时有频繁切换

4. 其他
流场景数据，
Cluster Scene，动态加载场景。

地表划分需要关注的点：
内存：Lightmap，如果不能忍受其实还是需要切块

个人注： 实际上多种方案可以结合做分层切块

### 导航

快速定位高度
* 前后端统一（数据导出）
* 快速索引（CPU）
* 内存数据量（导航数据）

1. Unity自带navigation

优点：不需要自己维护
缺点：自定义属性无法添加

2. C++
自己维护寻路库（Recast等），
优点：可以定制化，可以保证前后端数据一致性，自定义数据
缺陷：实现复杂

3. Physic射线检测

优点：简单，不需要代码，针对BoxCollider其实还行
缺点：不适合复杂地形

Raytrace生成网格分块加载

### 资源管理

* 内存加载带来卡顿
* 卸载干净
* 频繁小内存申请

#### IO层
禁止同步接口，Unity新的AUP加载流程
在销毁的时候尽可能用DestoryImm

贴图加载技术

* Vitrual texture
贴图二级索引，通过索引贴图，去找二级缓存，避免大贴图
* Cluster加载
把贴图加载压力分为两个，加载只是bytes流，用贴图的时候才用协程进行组装。有效把IO压力分离到底层多线程。

#### 内存层
缓存很重要：
* GameObject、Component代码对象做池子
* 申请大内存缓存：MBuffer（相邻内存提高cache命中率，其实ECS也是一样，当然在内存复用的时候也需要使用这个东西，以及防止内存碎片化）
* 多级缓存机制：移到很远地方 -> enable为false -> destroy
* 缓存池增长的做法：翻倍（让我想起了lua中的relloc申请内存方式）

（除此之外，RO的淘汰队列以及淘汰策略其实也对内存池有很大的作用）
在一定数量内的话是一直存放的最近使用，如果到一定数量之后则使用计时器释放，如果再多的话就直接释放。

总之还是要针对性能分析触发进行方案的定制，不同的机型可以做细致划分，例如安卓的内存较大，而ios cpu较强

## 后效渲染
问题：
* 屏幕区域后效区分化，不同区域的Bloom强度不同
* Distort效果兼容（需要Grab）
* 不同对象的后效区分化
* Blit带宽性能瓶颈
* Stencil buffer在OnRenderImage之前会被Clear依赖Depth buff

通过Stencil可以做区域划分但是如果Depthbuffer被清了就有问题。

后效合批

（将屏幕本身的屏幕贴到屏幕上，会更加省（PostProcessStack）


### 如何区分区域做后效

利用不透明物件的Alpha通道标记角色场景天空
读取屏幕信息存入readbacktexture
不透明物体开始后处理
Radback texture 清空，回拷
画半透明特效，用第一个读出来的distort截屏效果用 read backtexture
第二波后处理，用Alpha通道做判断

通过不同的Alpha决定不同区域的Bloom强度

## 性能

### Lua C# 与 C的合理使用
Lua用于写触发
计算逻辑放在C
C#作为轮询驱动器

### 调用注意点
PB避免高频调用，LuaFunction做缓存

### 多核利用
高频度逻辑，
* 首先可以用Thread，
* 2018可以使用JobSystem，更安全的多线程编写方式。Culling 网格变形 dynamic bone 等等
* 更高频则可以使用**ComputeShader**，利用GPU做高度并行的计算。粒子、蒙皮等
* Ring Buffer Laylap，Double Mesh Buffer（类似于双缓冲的Mesh版本）处理变化顶点，血条以及 flare lens

## 问题整理
Q : 同一个Tarrain里面的高度差太大导致精度不够
A : 实际上如果使用Mesh没这个问题，而Unity自带的这个则要分层Tarrain。

Q : Compute Shader支持程度
A : Compute Shader大部分高端机已经支持，根据高低端机进行分支

Q : 寻路部分，长寻路多产生压力大的问题
A ：Recast寻路，寻路分块，分块点与点之前联通进行离线生成。








