# Effect C++ 读书笔记——Chapter2
#读书笔记/C++/EffectiveC++

### 条款5：了解C++默默产生并调用了哪些函数

1. 默认构造函数
2. 默认析构函数
3. 默认拷贝构造函数
4. 默认拷贝赋值运算符

```
TestObject objA("aaa");
TestObject objB(objA);//使用了拷贝构造函数
objB = objA;//使用了拷贝赋值运算符
```

默认情况下拷贝构造函数中会将C++的所有成员都进行拷贝，但是有两种情况C++不会产生默认拷贝运算符：
成员对象中包含引用或者引用成员，因为引用本身不允许被修改，但是如果指向另一个成员也不正确，如果是const成员的话那压根就不允许修改，所以C++无法明确应该如何进行拷贝。

### 条款6：如果不想使用编译器自动生成的函数就明确拒绝

如果不允许使用者进行拷贝，则我们需要自己声明私有的拷贝构造函数，并不提供实现，这样的话，如果进行调用就会产生报错。
相应的，如果我们编写一个UnCopyable声明私有的但不定义拷贝构造函数以及拷贝赋值操作，那么只要继承这个类就可以防止被拷贝了。

### 条款7：为多态声明virtual析构函数

这个其实非常好解释，因为在父类中的析构函数中只析构了父类的对象，但是如果子对象包含自己的新对象时，父类的析构函数已经不满足子对象的析构需求了。
1. 如果要使用多态就定义虚构造函数
2. 但是如果一个class并不准备进行多态，那么就不要声明virtual析构函数，因为多余的虚函数表会增加对象的大小，因而影响效率。
3. 如果一个类本身不存在virtual析构函数就不要使用继承，否则就会产生内存泄漏的问题。

### 条款8：别让异常逃离析构函数

析构函数中抛出异常非常容易导致内存泄漏，所以不要在析构函数中抛出异常。
**解决方案：**
提供一个close函数，让客户在使用完毕之后可以自己进行释放，然后，倘若没有close则在析构函数当中也进行close。如果客户本身自己没有进行close，并且析构函数中抛出了异常只能把锅甩给客户了，因为提供了关闭的接口。

### 条款9：不要在构造以及析构函数中调用virtual函数

我们都知道，构造函数是从父类开始构造的，所以当在构造函数中调用虚函数的时候，子类还没有完成构造
 **“在构造函数的时刻，子对象实际上还处于父对象的状态”**
有时候就需要将相应的构造参数传递到父类的构造函数中进行处理，比较麻烦，但是也没办法。

### 条款10：令 operator= 返回一个 reference to * this

这个是一般协议而非编译器强制，如果没有特别好的理由就遵守这条规则。

### 条款11：在 operator= 中实现“自我赋值”

第一种方法是我们判断是否为同一个对象，如果是则返回，这样会有证同测试的消耗。
第二种则是直接进行swap然后删除原来的对象。

在实现的同时要保证操作一个以上的对象，并且多个对象是同一个对象的时候也要执行正确。

### 条款12：复制对象的时候不要忘记每一个部分

这其实也是和多态息息相关。
1. 在编写子类的copy函数的时候要注意不要忘记copy父类的对象（调用父类的copy函数）
2. 不要尝试用一个copy函数来调用另一个copy函数而是抽出来作为第三个函数并且两个都对其进行调用


