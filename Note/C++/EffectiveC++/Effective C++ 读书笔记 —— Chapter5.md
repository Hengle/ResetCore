# Effective C++ 读书笔记 —— Chapter5
#读书笔记/C++/EffectiveC++

### 条款26：尽可能延后变量声明的时间

延后变量的声明时间，不仅可以帮助你清晰代码，而且可以避免一些不必要的构造与析构开销。

### 条款27：尽量少做转型动作

几种转型的方式：

C语言风格：
1. (T)Expression
2. T(Expression) : 函数风格的转型

C++语言风格：
1. const_cast<T>(expression) ：常量转为普通变量
2. dynamic_cast<T>(expression) ： 安全向下转型
3. reinterpret_cast<T>(expression) ：低级转型，结果取决于编译器（操作原始内存）
4. static_cast<T>(expression) ： 强迫隐式转换，但是没办法改变常量性

建议：
1. 尽量避免转型，特别是注重效率的代码里面避免dynamic_cast，如果有设计必须要转型，看看能不能发展无需转型的解决方案。
2. 如果转型是必须的，能不能放在函数里面，让客户不需要自己转型。
3. 尽量使用C++的转型

### 条款28：避免返回handles指向对象的内部部分

返回handle，例如指针、引用之类的东西会导致类的封装性变差，并且使hande寿命比指向的对象更长的风险大大增加。尽量避免这种情况发生。
我们可以使用返回const引用的getter函数解决一部分问题，但是还是有可能出现悬吊的问题。

### 条款29：为异常安全而努力是值得的

异常安全的要求：
1. 不泄露任何资源
2. 不允许数据败坏

通过资源管理类我们可以很好保证资源不泄露

而资源败坏则需要我们保证几点：
* 基本承诺：没有任何数据对象与结构损坏
* 强烈保证：函数要么成功，要么保持调用前的状态
* 不抛掷保证：异常安全码

### 条款30：透彻了解inlining的里里外外

大多数的inling限制在小型、被频繁调用的函数身上，这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的提升机会最大化。
不要因为functiontemplate出现在头文件就声明了inline

### 条款31：将文件间的编译依存关系降至最低

一般有两种方法：
1. Handle Class : Class中本身不包含实现，而是将实现放在另外一个类中，而使用的类使用间接的方式使用实际类
2. Interface Class : 与Java和C#中的Interface一样，其中都是声明，而在实际类中进行实现。

程序的头文件应该是完全只有声明式，不论是否涉及到template都适用。