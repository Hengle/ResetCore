# Effective C++ 读书笔记 —— Chapter4
#读书笔记/C++/EffectiveC++

### 条款18：让接口容易被正确使用，不易被误用

通过以下的一些方法来改进易用性：
* 创建一个新的类型来作为参数，并在参数里面添加上限制条件。例如日期的话可以创建Day、Month、Year以确保易用性
* 使用shared_ptr帮助用户管理内存，必要时可以让客户使用自定义销毁方式。

### 条款19：设计class犹如设计type

* type如何被创建和销毁：分配与释放函数
* 对象初始化与赋值该有什么样的差别：对应不同的函数调用
* 新type对象如果被值传递意味着什么：决定copy函数
* 什么是新type的合法值：决定约束条件
* 你的新type需要配合某个继承图系：是否需要多态
* 你的新type需要什么样的转换：类族中需要哪些转换
* 什么样的操作符和函数对于此新type而言是合理的：应该声明哪些函数，哪些应该是成员函数
* 什么样的标准函数应该驳回：哪些函数应该私有
* 谁该取用新type的成员：开放哪些函数
* 什么是新type的未声明接口：
* 你的新type有多么一般化：新class还是用template

### 条款20：宁以 pass-by-reference-to-const 替换 pass-by-value

* 通过值传递的时候需要有大量的copy函数调用，大量构造调用。
* 而且通过值传递的时候可能只会出现割裂的问题，也就是传的参数是父类类型，自类的成员对象不会被传过去，会出现多态的问题。
* 但是对于STL迭代器以及函数而言还是使用传值较好。

### 条款21：必须返回对象时不要妄想返回引用

当你需要返回值得时候如果你使用了引用，会出现两种情况：
* 你使用了栈变量：函数结束后被释放，引用指向空
* 你使用了堆变量：你再也没办法拿到其指针，内存泄漏
所以该返回对象的时候还是返回对象吧。

### 条款22：将成员变量声明为private

也就是通常在java中C#中也会提到的使用getter以及setter替换直接访问。
这样对以后的重构会有较好的帮助。
注意：protected并没有比public好多少，因为子类中没办法进行重构了

### 条款23：使用非成员函数替换成员函数

当你要编写一些工具函数的时候最好抽成非成员函数而非直接加入到类之中，这样对于扩展性而言都有很大的好处。

### 条款24：如果所有参数都需类型转换，请为此采用non-member函数

如果你需要为所有的函数参数进行类型转换，请使用non-member

### 条款25：考虑写出一个不抛出异常的swap函数

* 当std::swap效率不高的时候，提供一个swap成员函数，并确定这个函数不抛出异常。
* 如果你提供了一个成员swap函数，也提供一个non-member swap来调用前者。对于class，而非template，请特化std::swap
* 调用swap时应针对std::swap使用using声明式，然后调用swap而且不带任何“命名空间修饰符”
* 为用户自定义类型进行std template全特化是好的，但是千万不要在std中加入对std是全新的东西
