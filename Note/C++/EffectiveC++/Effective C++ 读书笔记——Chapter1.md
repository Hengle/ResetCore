# Effective C++ 读书笔记——Chapter1
#读书笔记/C++/EffectiveC++ 

### 条款1：视C++为一个语言联邦
C++包含了各种各样的语言特性，其中主要包含了：

* 面向过程编程
* 面向对象编程
* 泛型编程
* 元编程
* 函数式编程

最好的方法将这些语言分开，在其该用的时候再进行使用。

### 条款2：以const、enum、inline替换#define
主要的理由还是让**“编译器替代预处理器”**

当你debug的时候你会发现#define会被具体的数字替换，这样的话当你debug的时候你就完全不知道这些魔数的含义到底是什么。

#### 常用的常量形式：
如果使用 char* 的时候要特别注意两边都要进行 **const**
`const char* const authorName = "Dong Chen"`

而使用string的时候就用不着这样了：
`const std::string authorName("Dong Chen")`

Class的专属常量需要加上static
``` 
class GamePlayer{
private:
//这就是在类里面的常量
static const int number = 5;
}
```

不过在使用的时候要注意如果编译器坚持要看到定义式则要提供定义式
`const int GamePlayer::number;`
反观#define就没办法创建类的专属常量的了，因为没有作用域的概念

如果编译器不允许static内置常量就可以使用enum试试看

```
class GamePlayer{
private:
	enum { Number = 3 };
}
```
这被称为 **“the enum hank”** 
可以防止别人通过指针或者引用来获取你的常量

形似于函数的宏最好使用**template inline**函数进行替代。

### 条款3：尽量使用const

const使用在指针上时如果在 * 的右边则说明指针本身是常量，如果在左边则说明指针指向的是常量
在实现运算符的时候，例如乘号 * 的时候要使返回值为const，否则可能会出现`( a * b ) = c`的诡异情况。也可以防止将 == 写为 = 时出现的情况。

const成员函数是为了让其能够操作const对象。
成员函数也能够被const进行重载。
如果操作的对象的常量性不同则会使用到不同的成员函数。

如果希望在const成员函数中也需要用到可变的额成员变量，则可以使用 mutable进行定义。

如果const与non-const两种函数的实现有重复的情形出现，则可以通过non-const函数调用const函数的方式来进行解决。

### 条款5：确定对象在使用前已经被初始化

* 内置类型要保证手动初始化，否则C++不保证其初始化
* 在构造函数中进行赋值的时候仅仅是 **赋值** 而非 **初始化** 所以最好还是使用初始化列表进行初始化，在初始化的时候要保证变量的顺序（防止数组之类需要赋予尺寸的变量出现问题）
* 父类的初始化总是在子类的前面
* 在不同编译单元的 **non-local static** 对象的初始化顺序无法被确定，所以我们不采用变量的方式，而是使用函数的方式来进行取用，某种程度上就是单例模式。防止在static对象未被初始化的时候使用而产生严重的问题。


