# 多地区管理

## 概览

国内分支保持自己的开发节奏进行开发（**但是针对功能需要提供开关功能，以做到可配置化**）。

海外从国内主分支切出分支用于修复bug，资源以及配置相关文件，**建立新的git库**进行差异化隔离，通过**覆盖**的方式进行地区化差异。

所有的功能都将在**国内主分支**完成开发，海外版本通过**开关**的方式逐步开启国内功能。

如果不进行升级，当海外版本需要新版本国内功能的时候则将国内版本功能进行移植（此类情况应尽量减少）。

**海外分支禁止修改一切的数据结构以及协议，不允许增加表Id**

当海外需要使用新的数据结构以及协议时，将需要首先在国内添加相同字段或者Id，而后在海外进行添加，防止字段冲突。

## 面临的问题以及解决问题的方向

海外版本往往是旧版本，如果在其之上进行开发则会造成枚举以及表格Id的冲突，在数据落地之后无法与主分支进行合并。

> 结论一：不在海外分支进行功能开发以及表Id与字段的添加

海外版本往往大部分将复用国内表格数据，仅修改少量资源

> 结论二：通过覆盖的方式对表格数据以及资源进行地区差异化

海外地区功能想要合回国内异常困难，国内多地区开发区分引起开发复杂度上升

> 结论三：所有功能将在国内开发，采用一个程序库，通过开关的方式把握海外玩法的节奏

## 创建新地区

以下文件夹通过覆盖的方式进行多地区差异化

* artres 在clientproj下添加子文件夹，添加新库，其中包含多个地区
* config 在config下添加子文件夹，其中包含多个地区
* Lua    在clientproj下artres所使用的子文件夹

以下文件夹在海外将不允许改动，如有需要则进行移植或升级海外版本。

* clientproj（除Lua外）
* clientcode
* rogamelib
* roserver

## 日常开发

前提：**国内将拥有所有的功能，海外则为国内功能的子集。**

所有的功能开发将在主分支上进行，并且需要支持开关以及可配置化。
其余和日常开发没有差别。

*如何开关需要在后续继续讨论*

## 版本升级

前提：海外不存在中间版本，升级只能与**拥有所依赖数据**的国内tag同步。

### 主库（以日本为例）：
release1.0.0 —————— jp1.0.0
|
|
|
release1.1.0 —————— jp1.1.0

1. 新建以及升级海外地区都直接从国内拉出分支，仅用于热更新修复问题不进行具体功能开发

### 海外库：
2. 仅使用**单线开发**，海外内容在各自文件夹中，热更新时将会打上不同地区的热更新tag
3. 版本升级之后，针对海外库内容进行升级，修改格式修改过的表，以及对于修改过的程序模块需要做适配（尽可能减少程序部分）


## 修复bug

release1.0.0 —————— jp1.0.0
|
|
|
release1.1.0

1. 在最旧的版本主线tag上拉出分支进行修复，并且合并到地区分支
2. 目前最新国内分支为1.1.0，将修复的分支合并到最新分支
3. 如果是海外库配置或Lua的问题则直接在海外库进行修复即可

## 多地区打包

多地区打包时需要将地区资源覆盖到国内资源，减少冗余资源。
Lua添加SearchPath即可
config则是使用母子表方式在读取层进行处理

海外则需要在打bundle时算入相应的海外路径

## 热更新

国内版本无需修改热更新流程
海外同样在打bundle时需要算上海外文件夹的路径，其余流程与国内无区别

## 切换分支速度优化

使用快捷方式切换Library缓存的方案，加快分支切换速度

## 每个工种在开发中需要注意的点

### 美术

国内开发无需修改任何流程
海外开发中，比较出问题的只有UI部分。
如果海外有大幅修改的UI，在功能升级之后需要关注不同UI对于功能需要对应。

### 策划

国内开发无需修改任何流程

海外仅允许存在两种开发行为：
* 适配
* 移植

海外开发配置修改中，有几条**红线**：

1. 不允许添加新的表Id，
2. 如果需要移植则，在主库添加表Id
3. 在海外分支不允许开发新的数据以及表相关功能
4. 若有需要则需要进行移植或升级操作，提需求需要谨慎

### 程序

国内开发开发时基本与以前一致，但是新功能需要支持**开关机制**。

在海外开发时也有几条**红线**：

1. 不允许对现有数据结构进行修改（包括协议以及场景数据的pb）
2. 不允许添加表字段
3. 针对海外Lua开发仅开放简单的调整接口，而不包含具体复杂功能

海外如有功能需求，并不进行版本升级，则需要在国内进行开发，并且支持开关机制，而后进行移植。

## SDK相关

单独建库，后续开发时进行整理
