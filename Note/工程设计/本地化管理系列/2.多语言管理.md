# 多语言管理

问题：多个字符串池如何合并
*暂时不考虑图片以及音效等*

## 现有的字符串池

* UI字符串
* 代码中的字符串
* 表格中的字符串
* 剧本中的字符串

## 目标

* 去冗余
* 可热更
* 增量式添加字段
* 策划无感知

## 初步设计

自增id为key，公用一个字符串池。

以下是操作方案：

* UI字符串添加扫描工具，Text以及TMP思考无感知本地化方法。
* 代码中的字符串沿用原来的方式进行记录，id需要改为自增
* 剧本改为编译式，使用二进制而非使用字符串记录，命令将记录id，参数添加本地化参数，编译时只抽出需要本地化的参数。
* 表格已有字符串数组改为记录id，bytes数组进一步缩小了。

## 检查目标

* 去冗余：由于是单个字符串池，所以已达成
* 可热更：由于是自增增量式，所以支持热更新字段
* 增量式添加字段：自增id，当添加新字符串都将加到最后
* 策划无感知：剧本在编译时抽出，表格在导出时抽出，代码需要程序自行处理，UI通过工具扫描，对于策划而言都是无感知的。达成

## 存在问题

### 问题：

id为key将存在冲突问题，在多人编辑下自增key将导致一方需要重新生成key。

### 解决方案：

所以将直接采用字符串作为key，中文作为key。
*添加新目标：方便合并*

### 问题：

但是中文作为key存在长字符串大量废弃的情况，翻译将面临冗余工作。去冗余目标无法达成。
剧本大部分为长字符串，其他则都为长短混合型

### 解决方案：

分为3种类型的表：

1. 复用表
2. 长字符串表
3. 长字符串翻译表

当字符串（value）长度小于n则使用复用表，否则采用长字符串表。

短字符串查看在复用表中是否存在，如果存在则采用复用表id，否则插入。
长字符串查找长字符串翻译表，如果存在则采用长字符串翻译表id，否则插入。并且每个翻译单元生成单个长字符串表用于后期合并。

提供给翻译的将是将各个长字符串表以及复用表的并集，其中长字符串新翻译部分加入长字符串表。

在打包时将复用表以及所有长字符串表合并为一个大的Localization表。

> 最后决定不采用该方式，在日常开发的时候不应该关心多语言的事情，而应该在需要翻译的时候进行统一导出

### 问题：

分字符串表之后的key冲突问题

### 解决方案：

当复用表与长字符串表若存在冲突则在打包的时候产生报错。

## 最终方案

### 概览

国内使用Key表，国外则使用翻译表。
国内在平时的时候使用一张FULLKEY来包含所有开发当中使用到的Key。
在需要翻译得时候将用到的字段全部导出到key表中（可进行分表）。

海外也存在相应的全量翻译表，将全量翻译表的内容灌入Key表

将翻译表生成Excel交给翻译公司。

翻译完毕之后将Excel导出为翻译表，并且将新的字段灌入全量翻译表，为下次比对做准备。

打包的时候进行二进制转换，在发布版中使用二进制进行读取。

> 在给与翻译公司的时候，我们的Key表将自带注释，用于帮助翻译理解上下语义
> 剧情方面需要知道剧本的说话方是哪个Npc以在不同语义下翻译

### 导出阶段

4个部分的导出：

#### UI导出部分

UI直接遍历Prefab并且进行抽出，
需要注意的是我们的Prefab上面会有临时文字，所以需要在Prefab的组件上面添加是否需要本地化的选项。

#### 表格导出部分

表格需要给策划进行字段，决定是否需要本地化。
字符串部分，最终决定是使用C#来取字符串，而C++部分仅仅存序号，
这样的好处是C#底层的虚拟机存取了所有的字符串，不需要在C++再存一遍。

服务器不允许使用字符串，所以需要本地化的字段，将不会在服务器部分导出。

#### 剧本导出部分

遍历就完了

#### Code导出部分

代码依旧使用自定义key，但是这个key将索引到一个索引，使用这个索引到字符串池去取字符串，
这样的好处是，当文字改变时无需修改代码。

### 运行时阶段

依旧是4个部分考虑

#### UI运行时部分

UI在Awake的时候替换字符串。
运行时语言切换//TODO

#### 表格运行时部分

表格部分在C++部分使用index进行索引，然后在上层在C#字符串池中进行取字符串。

#### 剧本运行时部分

剧本使用编译式
//TODO

#### Code运行时部分

基本与导出部分描述相同，运行时将搜索两次，进行解耦。